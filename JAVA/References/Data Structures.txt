Data Structures
---------------

Data structure is a triod of (type,range,operations)


A DS is a way of organizing, storing and managing data so that it can be
used efficiently ( Programming Concepts)

Organize the books in shelf -- Book racks
Dictionary --- Printed Books
Queues at ticket counters -- materials
Student Register -- Books 

Why DS ?

1. Efficient for data storage
2. Faster searching and sorting
3. Better performance
4. Scalbale applications

DS ---> classified ---> Linear and Non-Linear DS

Linear Structures store the data in  linear fashion (sequentially)
Eg> Array, Stack, Queue, LinkedList (single linked, doublelinked list, 
circular linked list)


Array is a linear data structure, where it can store multiple values linearly
ie each memory location is continuous and they will store the data of same kind

int[] array = new int[5];


Non Linear structures does not store data sequentially
Eg> Trees and Graphs


Sorting and Searching Algorithms -->

1. linear search ----> contains()

a = [10,20,1,30,45,16,22]   search --> 10 --> most time taking process

1. Best case --> first element -- O(1) ---> 
2. worst case --> last element -- O(n)
3. Average case --> middle element -- O(n)

Linear search is best suited when elements cannot be sorted


int[] a = new int[50];

x <--search element <--- 16
x=16


public int linearSearch(a,x) {
for(int i=0;i<a.length();i++){
	if( x == a[i]){

		return i;
		
	}
}
return -1;
}

int pos = linearSearch(a,16);
if(pos>0)
	System.out.println("Element is found at "+pos);
else
	System.out.println("Element not found");


2. binary search ---> binarySearch() -- Divide and Conquer Technique

for a binary search to implement, elements must be in sorted order


a = [1,10,16,20,22,30,45]  7 ---> 3, 100 ---> 15, 1000 ---> 50
x = 11

20 != 16 [ middle value is not equal)

x > a[i] or x < a[i]

16< a[i] (20)

Best case --> O(1)
Worst Case ---> O(log n)
Average Case --> O(log n)

public int binarySearch(a,x){
	int low=0, high = a.length()-1;
    while(low <= high){ 0 <= 2
		int mid = (low+high)/2;
		if( a[mid]==x)
			return mid;
		else if (x < a[mid] )
			high = mid -1;
		else
			low = mid + 1;
     }
     return -1;
}

class Sorting{
	public int binarySearch(a,x){
	int low=0, high = a.length()-1;
    while(low <= high){ 0 <= 2
		int mid = (low+high)/2;
		if( a[mid]==x)
			return mid;
		else if (x < a[mid] )
			high = mid -1;
		else
			low = mid + 1;
     }
     return -1;
}
public int linearSearch(a,x) {
for(int i=0;i<a.length();i++){
	if( x == a[i]){

		return i;
		
	}
}
return -1;
}
}

Sorting sorting = new Sorting();
//int k = sorting.linearSearch(a,x);
int k = sorting.binarySearch(a,x);
if(k>0)
  System.out.printl("element found at ",k);
else
  System.out.println("Element not found");

	


3. jump search -----> Linear + Binary

jump size 

directly jump to the jump size and compares 

10 20 30 40 50 60 70 80 90 100

search = 80
jumpsize = sqrt(n) --> sqrt(10)-->3

a[0]--10
a[3] -- 40
a[4]--50
a[5]
a[6]-- 70


1. Jump search is useful when the data is represented in block 
2. Random access is expensive
3. 


Time complexity for the jump search --.
Best case = O(1) 
Avg  case -  O(sqrt(n))

Binary search, this is not fast

Sorting 
-------
1. sort() ---> it is a method in collections class provides the sorting functionality

1. bubble sort
2. quick sort
3. merge sort
4. heap sort

Strategies

1. Divide and Conquer
2. Greedy Method
3. Dynamic Programming

Non Linear Structures

1. Trees - types of trees - traversing - application
2. Graph -- types of graphs - traverse - applications

Sorting is the process of arranging the values either in the increasing value
or decreasing value

Bubble Sort -- Exchange Sort --  very slow in performance

[5,1,4,2,8]

1,5,4,2,8

1,4,5,2,8

1,2,5,4,8

1,2,4,5,8--> final sorted array

Best case - already all elements are in sorted order  - O(n)

Worst case - O(n2) 5, 4, 3, 2, 1

Avg case - O(n2) 

public int bubbleSort(int[] x


Merge sort
----------
 It follows divide and conquer strategy


Complexity of Merge Sort


1. Best --> O(n log n)

2. Average --> O( nlogn)

3. Worst ----> O( n log n)

Quick Sort
------------

[10,7,8,9,1,5]---> unsorted array
10 7 8 9 5 1
first, last , random

[1 5 10 7 8 9]

[1] 5 [10 7 8 9]

[1] 5 [7 8 9 10]

[1] 5 [7 8] 9 [10]

[1 5 ] [ 7 8 ] [9 10]

[1 5 7 8 ] [ 9 10]

[1 5 7 8 9 10 ]

Recursion and Divide and Conquer 

Time Complexities

1. Best case O(n log n)
2. Average case is O(n log n)
3. worst case : O(n2)

Adv:
1. very fast 
2. in place sorting
3. cache friendly
4. Widely used tech in many pre defined methods Arrays.sort()--> Quick


