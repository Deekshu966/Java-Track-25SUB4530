Data Structures
---------------

Data structure is a triod of (type,range,operations)


A DS is a way of organizing, storing and managing data so that it can be
used efficiently ( Programming Concepts)

Organize the books in shelf -- Book racks
Dictionary --- Printed Books
Queues at ticket counters -- materials
Student Register -- Books 

Why DS ?

1. Efficient for data storage
2. Faster searching and sorting
3. Better performance
4. Scalbale applications

DS ---> classified ---> Linear and Non-Linear DS

Linear Structures store the data in  linear fashion (sequentially)
Eg> Array, Stack, Queue, LinkedList (single linked, doublelinked list, 
circular linked list)


Array is a linear data structure, where it can store multiple values linearly
ie each memory location is continuous and they will store the data of same kind

int[] array = new int[5];


Non Linear structures does not store data sequentially
Eg> Trees and Graphs


Sorting and Searching Algorithms -->

1. linear search ----> contains()

a = [10,20,1,30,45,16,22]   search --> 10 --> most time taking process

1. Best case --> first element -- O(1) ---> 
2. worst case --> last element -- O(n)
3. Average case --> middle element -- O(n)

Linear search is best suited when elements cannot be sorted


int[] a = new int[50];

x <--search element <--- 16
x=16


public int linearSearch(a,x) {
for(int i=0;i<a.length();i++){
	if( x == a[i]){

		return i;
		
	}
}
return -1;
}

int pos = linearSearch(a,16);
if(pos>0)
	System.out.println("Element is found at "+pos);
else
	System.out.println("Element not found");


2. binary search ---> binarySearch() -- Divide and Conquer Technique

for a binary search to implement, elements must be in sorted order


a = [1,10,16,20,22,30,45]  7 ---> 3, 100 ---> 15, 1000 ---> 50
x = 11

20 != 16 [ middle value is not equal)

x > a[i] or x < a[i]

16< a[i] (20)

Best case --> O(1)
Worst Case ---> O(log n)
Average Case --> O(log n)

public int binarySearch(a,x){
	int low=0, high = a.length()-1;
    while(low <= high){ 0 <= 2
		int mid = (low+high)/2;
		if( a[mid]==x)
			return mid;
		else if (x < a[mid] )
			high = mid -1;
		else
			low = mid + 1;
     }
     return -1;
}

class Sorting{
	public int binarySearch(a,x){
	int low=0, high = a.length()-1;
    while(low <= high){ 0 <= 2
		int mid = (low+high)/2;
		if( a[mid]==x)
			return mid;
		else if (x < a[mid] )
			high = mid -1;
		else
			low = mid + 1;
     }
     return -1;
}
public int linearSearch(a,x) {
for(int i=0;i<a.length();i++){
	if( x == a[i]){

		return i;
		
	}
}
return -1;
}
}

Sorting sorting = new Sorting();
//int k = sorting.linearSearch(a,x);
int k = sorting.binarySearch(a,x);
if(k>0)
  System.out.printl("element found at ",k);
else
  System.out.println("Element not found");

	


3. jump search -----> Linear + Binary

jump size 

directly jump to the jump size and compares 

10 20 30 40 50 60 70 80 90 100

search = 80
jumpsize = sqrt(n) --> sqrt(10)-->3

a[0]--10
a[3] -- 40
a[4]--50
a[5]
a[6]-- 70


1. Jump search is useful when the data is represented in block 
2. Random access is expensive
3. 


Time complexity for the jump search --.
Best case = O(1) 
Avg  case -  O(sqrt(n))

Binary search, this is not fast

Sorting 
-------
1. sort() ---> it is a method in collections class provides the sorting functionality

1. bubble sort
2. quick sort
3. merge sort
4. heap sort

Strategies

1. Divide and Conquer
2. Greedy Method
3. Dynamic Programming

Non Linear Structures

1. Trees - types of trees - traversing - application
2. Graph -- types of graphs - traverse - applications

Sorting is the process of arranging the values either in the increasing value
or decreasing value

Bubble Sort -- Exchange Sort --  very slow in performance

[5,1,4,2,8]

1,5,4,2,8

1,4,5,2,8

1,2,5,4,8

1,2,4,5,8--> final sorted array

Best case - already all elements are in sorted order  - O(n)

Worst case - O(n2) 5, 4, 3, 2, 1

Avg case - O(n2) 

public int bubbleSort(int[] x


Merge sort
----------
 It follows divide and conquer strategy


Complexity of Merge Sort


1. Best --> O(n log n)

2. Average --> O( nlogn)

3. Worst ----> O( n log n)

Quick Sort
------------

[10,7,8,9,1,5]---> unsorted array
10 7 8 9 5 1
first, last , random

[1 5 10 7 8 9]

[1] 5 [10 7 8 9]

[1] 5 [7 8 9 10]

[1] 5 [7 8] 9 [10]

[1 5 ] [ 7 8 ] [9 10]

[1 5 7 8 ] [ 9 10]

[1 5 7 8 9 10 ]

Recursion and Divide and Conquer 

Time Complexities

1. Best case O(n log n)
2. Average case is O(n log n)
3. worst case : O(n2)

Adv:
1. very fast 
2. in place sorting
3. cache friendly
4. Widely used tech in many pre defined methods Arrays.sort()--> Quick


Trees and Graphs
---------------
These are non linear DS which are most widely used in databases, filesystems, 
compilers, search engines and networkings


family hierarchy -- tree
File System --- Tree

route from given source to destination - Graph

Tree is a non linear DS consisting of nodes, where
one node is desginated as root (a node which does not any predecesors)
every other node have child nodes
There are no cycles 

Terminologies:
---------------
1. root - Top most node which has no predecesors

2. Parent -- Node that has a children

3. child - Node emerged from other node

4. leaf - node which doesnot have any children

5. siblings - nodes with same parent

6. Edge - path connecting two nodes

7. Level - depth from root

8. Height -Max depth of tree

9. subtree -- Tree formed from any node


Types of Trees
--------------

1. General Tree

2. Binary Tree - every node has at most 2 children only

3. Binary Search Tree --> all the left node values must be less than the 
root and right node values must be greater than the root

4. Balanced Trees ( AVL, Red-Black)


5. Heap Tree (Min / Max heap)

6. Trie -- Strings

Moving from one node to another node in tree is called Traversals

Three types of traversals

1. InOrder--> visit Left node --> root ---> visit right node
2. PreOrder ---> vist root ---> left ----> right
3. PostOrder --> left --> right ---> root

InOrder --> 12,25,50,75,100

PreOrder ->50, 25, 12, 75,100

PostOrder -> 12, 30, 25, 60, 100, 75, 50



Node --> create a class where data, ref to the same class as left and right



Binary Search Tree
-------------------

BST may become un balanced while inserting nodes into it


Red-Black Trees and AVl Trees, these are called self balancing trees


AVL (Adelson-Velsky-Landis)
---------------------------
An AVL is a self balancing binary search tree, where the height diff between left and right
subtrees of any node is at most 1


balance factor = diff of left height and right height of sub trees

How do this will make as balanced

AVl tree uses rotations to adjust the tree to be balance

LL Rotations
	- Insertion in the left subtree of left child
	- Fix this with Right Rotation
RR Rotations
	- Insertion in right subtree of right child
	- Fix this with left Rotation
LR Rotations
	- Left child -> right insertion
	- Fixed with Left and Right rotations
RL Rotations
	- Right Child -> left insertion	
	- Fixed with Right and left rotations


search  -- O(log n)

insert - O(log n)

delete - O (log n)


opertions on avl tree - insert, delete, search, rotations, traversals

Red - Black Tree
---------------

A Red-Black tree is a binary search tree in which each node has either red or black 
color and the tree maintains balances using these colors and rotations


Rules to be followed for Red-Black Trees

1. Every node is either red or black
2. The root is always black
3. no two red nodes can be adjacent
4. every path from a node to its descendant null nodes has the same number of black nodes
5. all null (leaf) nodes are considered as black.



We will make tree balanced by recoloring and use rotations on when it is mandatory

Rotations we use are - Left Rotation or Right Rotation ( rotations depends on
Parent color and uncle color)


Applications of Red Black Trees

1. Event Driven Systems
2.  Memory Management Systems
3. Networking
4. Compilers and Interpretors
5. Database indexes
6. OS process scheduling





















