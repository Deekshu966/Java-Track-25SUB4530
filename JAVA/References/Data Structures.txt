Data Structures
---------------

Data structure is a triod of (type,range,operations)


A DS is a way of organizing, storing and managing data so that it can be
used efficiently ( Programming Concepts)

Organize the books in shelf -- Book racks
Dictionary --- Printed Books
Queues at ticket counters -- materials
Student Register -- Books 

Why DS ?

1. Efficient for data storage
2. Faster searching and sorting
3. Better performance
4. Scalbale applications

DS ---> classified ---> Linear and Non-Linear DS

Linear Structures store the data in  linear fashion (sequentially)
Eg> Array, Stack, Queue, LinkedList (single linked, doublelinked list, 
circular linked list)


Array is a linear data structure, where it can store multiple values linearly
ie each memory location is continuous and they will store the data of same kind

int[] array = new int[5];


Non Linear structures does not store data sequentially
Eg> Trees and Graphs


Sorting and Searching Algorithms -->

1. linear search ----> contains()

a = [10,20,1,30,45,16,22]   search --> 10 --> most time taking process

1. Best case --> first element -- O(1) ---> 
2. worst case --> last element -- O(n)
3. Average case --> middle element -- O(n)

Linear search is best suited when elements cannot be sorted


int[] a = new int[50];

x <--search element <--- 16
x=16


public int linearSearch(a,x) {
for(int i=0;i<a.length();i++){
	if( x == a[i]){

		return i;
		
	}
}
return -1;
}

int pos = linearSearch(a,16);
if(pos>0)
	System.out.println("Element is found at "+pos);
else
	System.out.println("Element not found");


2. binary search ---> binarySearch() -- Divide and Conquer Technique

for a binary search to implement, elements must be in sorted order


a = [1,10,16,20,22,30,45]  7 ---> 3, 100 ---> 15, 1000 ---> 50
x = 11

20 != 16 [ middle value is not equal)

x > a[i] or x < a[i]

16< a[i] (20)

Best case --> O(1)
Worst Case ---> O(log n)
Average Case --> O(log n)

public int binarySearch(a,x){
	int low=0, high = a.length()-1;
    while(low <= high){ 0 <= 2
		int mid = (low+high)/2;
		if( a[mid]==x)
			return mid;
		else if (x < a[mid] )
			high = mid -1;
		else
			low = mid + 1;
     }
     return -1;
}

class Sorting{
	public int binarySearch(a,x){
	int low=0, high = a.length()-1;
    while(low <= high){ 0 <= 2
		int mid = (low+high)/2;
		if( a[mid]==x)
			return mid;
		else if (x < a[mid] )
			high = mid -1;
		else
			low = mid + 1;
     }
     return -1;
}
public int linearSearch(a,x) {
for(int i=0;i<a.length();i++){
	if( x == a[i]){

		return i;
		
	}
}
return -1;
}
}

Sorting sorting = new Sorting();
//int k = sorting.linearSearch(a,x);
int k = sorting.binarySearch(a,x);
if(k>0)
  System.out.printl("element found at ",k);
else
  System.out.println("Element not found");

	


3. jump search -----> Linear + Binary

jump size 

directly jump to the jump size and compares 

10 20 30 40 50 60 70 80 90 100

search = 80
jumpsize = sqrt(n) --> sqrt(10)-->3

a[0]--10
a[3] -- 40
a[4]--50
a[5]
a[6]-- 70


1. Jump search is useful when the data is represented in block 
2. Random access is expensive
3. 


Time complexity for the jump search --.
Best case = O(1) 
Avg  case -  O(sqrt(n))

Binary search, this is not fast

Sorting 
-------
1. sort() ---> it is a method in collections class provides the sorting functionality

1. bubble sort
2. quick sort
3. merge sort
4. heap sort

Strategies

1. Divide and Conquer
2. Greedy Method
3. Dynamic Programming

Non Linear Structures

1. Trees - types of trees - traversing - application
2. Graph -- types of graphs - traverse - applications

Sorting is the process of arranging the values either in the increasing value
or decreasing value

Bubble Sort -- Exchange Sort --  very slow in performance

[5,1,4,2,8]

1,5,4,2,8

1,4,5,2,8

1,2,5,4,8

1,2,4,5,8--> final sorted array

Best case - already all elements are in sorted order  - O(n)

Worst case - O(n2) 5, 4, 3, 2, 1

Avg case - O(n2) 

public int bubbleSort(int[] x


Merge sort
----------
 It follows divide and conquer strategy


Complexity of Merge Sort


1. Best --> O(n log n)

2. Average --> O( nlogn)

3. Worst ----> O( n log n)

Quick Sort
------------

[10,7,8,9,1,5]---> unsorted array
10 7 8 9 5 1
first, last , random

[1 5 10 7 8 9]

[1] 5 [10 7 8 9]

[1] 5 [7 8 9 10]

[1] 5 [7 8] 9 [10]

[1 5 ] [ 7 8 ] [9 10]

[1 5 7 8 ] [ 9 10]

[1 5 7 8 9 10 ]

Recursion and Divide and Conquer 

Time Complexities

1. Best case O(n log n)
2. Average case is O(n log n)
3. worst case : O(n2)

Adv:
1. very fast 
2. in place sorting
3. cache friendly
4. Widely used tech in many pre defined methods Arrays.sort()--> Quick


Trees and Graphs
---------------
These are non linear DS which are most widely used in databases, filesystems, 
compilers, search engines and networkings


family hierarchy -- tree
File System --- Tree

route from given source to destination - Graph

Tree is a non linear DS consisting of nodes, where
one node is desginated as root (a node which does not any predecesors)
every other node have child nodes
There are no cycles 

Terminologies:
---------------
1. root - Top most node which has no predecesors

2. Parent -- Node that has a children

3. child - Node emerged from other node

4. leaf - node which doesnot have any children

5. siblings - nodes with same parent

6. Edge - path connecting two nodes

7. Level - depth from root

8. Height -Max depth of tree

9. subtree -- Tree formed from any node


Types of Trees
--------------

1. General Tree

2. Binary Tree - every node has at most 2 children only

3. Binary Search Tree --> all the left node values must be less than the 
root and right node values must be greater than the root

4. Balanced Trees ( AVL, Red-Black)


5. Heap Tree (Min / Max heap)

6. Trie -- Strings

Moving from one node to another node in tree is called Traversals

Three types of traversals

1. InOrder--> visit Left node --> root ---> visit right node
2. PreOrder ---> vist root ---> left ----> right
3. PostOrder --> left --> right ---> root

InOrder --> 12,25,50,75,100

PreOrder ->50, 25, 12, 75,100

PostOrder -> 12, 30, 25, 60, 100, 75, 50



Node --> create a class where data, ref to the same class as left and right



Binary Search Tree
-------------------

BST may become un balanced while inserting nodes into it


Red-Black Trees and AVl Trees, these are called self balancing trees


AVL (Adelson-Velsky-Landis)
---------------------------
An AVL is a self balancing binary search tree, where the height diff between left and right
subtrees of any node is at most 1


balance factor = diff of left height and right height of sub trees

How do this will make as balanced

AVl tree uses rotations to adjust the tree to be balance

LL Rotations
	- Insertion in the left subtree of left child
	- Fix this with Right Rotation
RR Rotations
	- Insertion in right subtree of right child
	- Fix this with left Rotation
LR Rotations
	- Left child -> right insertion
	- Fixed with Left and Right rotations
RL Rotations
	- Right Child -> left insertion	
	- Fixed with Right and left rotations


search  -- O(log n)

insert - O(log n)

delete - O (log n)


opertions on avl tree - insert, delete, search, rotations, traversals

Red - Black Tree
---------------

A Red-Black tree is a binary search tree in which each node has either red or black 
color and the tree maintains balances using these colors and rotations


Rules to be followed for Red-Black Trees

1. Every node is either red or black
2. The root is always black
3. no two red nodes can be adjacent
4. every path from a node to its descendant null nodes has the same number of black nodes
5. all null (leaf) nodes are considered as black.



We will make tree balanced by recoloring and use rotations on when it is mandatory

Rotations we use are - Left Rotation or Right Rotation ( rotations depends on
Parent color and uncle color)


Applications of Red Black Trees

1. Event Driven Systems
2.  Memory Management Systems
3. Networking
4. Compilers and Interpretors
5. Database indexes
6. OS process scheduling


Heap Tree
---------
A heap tree is a complete binary tree satisfies the heap property

All levels are completly filled except possibly the last and nodes are filled 
from let to right.



Heap Trees - 1. Min Heap and 2. Max Heap
Operations - insert ( Heapify up) 2. delete , Heapify 

index formula to construct the trees

1. Parnet   (i-1)/2 child
2 lef child - 2i+1

2. right child - 2i+2

10 20 15 30 40


10


Graphs
------
A graph is a non linear DS consisting of set of vertices and edges

G = (V,E)

V = (v1,v2,v3,v4...vn)
E = (e1,e2, e3, e4...en)

Where are graphs used:

1. social networking
2. computer networking
3. web page navigation
4. google maps

Terminology:

1.Vetex - Individual element
2. edge - Path connecting any two vertices
3. Degree - Number of edges connected to a vertex
4. Path - Sequence of vertices
5. cycle - Path that starts and ends at same vertex

Types of Graphs

1. Un directed graphs - Edges have no direction, connection is two-way

2. Directed Graph - Edges have a direction, one -way direction

3. weighted Graph  - every edge has some cost / value

4. un weighted graph - All edges have the same weight

5. connected graph - Every vertex is reachable from every other vertex

6. disconnected graph - some vertices have no path between them

7. Tree (Special Graph) - A connected graph with no cycle, there will be only one path
   for any given two vertices

8. complete Graph - Every vertex is connected to other vertex directly


Operations - insert, search, traverse

traverse - BFS, DFS


How to represent a graph

1. Adjacency Matrix ( other java )

2. Adjacency List ( Java )



List<Integer> numbers = new ArrayList<>();

List<String> names = new ArrayList<>();

List<Integer> l1 = new ArrayList<>(); 
l1.of(0,1,1,1); ---> 

List<Integer> l2 = new ArrayList<>(); 
l2.of(1,0,0,1); ---> 

List<Integer> l3 = new ArrayList<>(); 
l2.of(1,0,0,1); ---> 

List<Integer> l4 = new ArrayList<>(); 
l2.of(1,1,1,0); ---> 


List<List<Integer>> graph = new ArrayList<>();
graph.add(l1);
graph.add(l2);
graph.add(l3);
graph.add(l4);


Map<String,List> graph = new HashMap<>();

graph.put("v1",l1);
graph.put("v2",l2);
graph.put("v3",l3);
graph.put("v4",l4);

Traversing 

1. BFS -- Breadth First Search  (Queue) 

2. DFS -- Depth First Search (Stack)

DFS starts from a source node, visits one of its neighbor, then continues visiting the
neighbors until there is no neighbor progress is possible, and then backtracks

It uses stack and recursion




1. Dijkstra's Algorithm
2. Floyd Warshal Algorithm




Dijksta's Algorithm
---------------------
1. Initialize distance of source vertex as 0
2. Initialize all other distances as  Infinity
3. Mark all vertices as unvisited
4. Repeat until all vertices are visited:
	4.1 Pick the unvisited vertex with min distance
	4.2 Mark as visited
	4.3 update distances of its adjacent vertices



Vertex			distance		Visited

A			 0			x

B			 inf			x

C			 inf			x

D 			 inf			x

E			 inf 			x

update the distance of neighbours from A

Vertex			distance		Visited

A			 0			y

B			 4			x

C			 2			x

D 			 inf			x

E			 inf 			x


visit c ( min of 4 and 2 is 2)
update the disntances of neighbours From c

C --> B = 2 +1 =3 (beter than 4)
C -> D = 2 + 8 = 10
C -> 2 + 10 = 12


Vertex			distance		Visited

A			 0			y

B			 3			y

C			 2			y

D 			 10			x

E			 12 			x

Step -3 : Visit B
update the neighbours 
	

vertex			distance		Visited

A			 0			y

B			 3			y

C			 2			y

D 			 8			y

E			 12			x

Step-4 : visit E
A -> C 	12
A - C - B -> D - >E = 10

vertex			distance	    Visited

A			 0			y

B			 3			y

C			 2			y

D 			 8			y

E			 10			y


Limitation for Alogrithm - It will not work for negative weights

Time Complexity:  Array - O(v*v)

Priority Queue (Heap ) -- O(V+E Log V)


Dynamic Programing Style - Floyd-Warshall  - used to find the shortest path between all pairs
of vertices in the weighted graph


step1 - Intialize the distance matrix
step2 - find any node as intermediate node and update the distance through this node 


When to use Floyd-Warshall
---------------------------
1. We need the shortest path for every pair of nodes in the graph
2. Dense graph
3. Networking routing tables
4. Cycle

Time Complexity - O(v*v)


Dijkstras -- used when single source is used
Floyd-Warshall - used for all pairs


Kruskals Algorithm - Min spanning Tree(MST)
-------------------------------------------
A min spanning tree is a subset of edges of a connected, undirected weighted graph, that
1. connects all vertices
2. contains no cycles
3. has the min possible total edge weight


Step1 - Sort all edges by weight

1-2 : 2
1-3 : 3


step2 - Intialize disjoint sets

{1} {2} {3}..{5}

{1 2}, {3}, {4}, {5}

{1 2 3}


1 - 2 : 1
2 - 3 : 2
2 - 4 : 4
3 - 5 : 6


algorithm

1. sort all edeges in increasing order of weight
2. initialize a disjoint set for each vertex
3. for each edge:
	3.1 if it doesnot form a cycle
		3.1.1 include int mst
		3.1.2 union the two vertices
4. stop when mst has v-1 edges



Time Complexity

Sorting Edges -- O(E Log E)
Unioin = O(E)

Total  = O(E Log E)


Bellman-Ford Algorithm
----------------------

single source shortest path algorithm that finds the shortest distance from a source vetex
to all other vertices in a weighted graph even if it has negative weighted edges.


When to use ?

1. negative edge weights
2. When cycle detection is required
3. in routing protocols
4. When correctness is more than speed (efficieny)


Works on the principle of relax edges

if dist[u] + w < dist[v]
  dist[v]= dist[u]+w



From		To		Weight
A		B		1
B		C		3
A		C		10
C		D		-2
D		B		-1



Step-1: Select source as A and update source distance to 0 and others as inf


Vertex 		Distance
A		0
B		inf
C		inf
D		inf


Steps-2 Relax all Edes (V-1= 3 Times)


iteration-1 :

A->B dist[B] = 1
A-C dist[C] = 10
B-C dist[c] = 4
C-D dist[d]= 2
D->B dist[B] = 1 (improvement )

Vetex		distance
A		0
B		1
C		4
D		2


Step-3 - Negative Cycle Detection


Time complexity - O(V x E)










