


class Employee{

	public void method1(){
		//logic
	}
	public void method2(){
		//logic
	}
}

Employee e1 = new Employee();
e1.method1();
e1.method2();

Employee e2 = new Employee();
e2.method1();
e2.method2();


100, n number o f objects



class Shop{

	public void selectItems(){
		System.out.println("Items were selected manually from shop");
	}
	public void payment(){
		System.out.println("Cash Payment");
	}
	public void shipment(){
		System.out.println("items to be carried with customer only");
	}
}


Shop village = new Shop();
Shop town =new Shop();
Shop city = new Shop();


village.selectItems();
village.payment();
village.shipment():



town.selectItems();
town.payment();
town.shipment();



city.selectItems();
city.payment();
city.shipment();


Interfaces
----------

Interface is an java entity, which contains all abstract methods;

An abstract method is a method which does not contain method definition / body

public void shipment();  --> abstract method

interfaces start with keyword called "interface"

syntax:

interface <interfacename>{
	// all  abstract methods;
}



// interfaces will define the rules also

Objects cannot be created directly for interfaces, all interfaces are immature entities
	

implements is keyword used for extending interfaces methods

Method Overriding - It is the process of suppressing base class method in the derived class
when both are having the same signature


interface Shop{
	public void selectItems();
	public void payment();
	public void shipment();
}


class VillageShop implements Shop{

	public void selectItems(){
		System.out.println("Items were selected manually from shop");
	}
	public void payment(){
		System.out.println("Cash Payment");
	}
	public void shipment(){
		System.out.println("items to be carried with customer only");
	}
}


VillageShop v1 = new VillageShop();
v1.selectItems();
v1.payment();
v1.shipment();


class A{

	int x;
	int y;
	A(){
	   x=10;
	   y = 20;
	}
	public void display(){
		SOP(x+" "+y);
	}

}

class B extends A {
	int x;
	int y;
	B(){
	 x = 300;
	 y = 400;
	}
	public void display(){
		SOP(x+" "+y);
	}
}

B b = new B();
b.display();

// abstract classes 

class CityShop implements Shop{

	@Override // to check whether the same method from base class is overridden or not
	public void selectItems(){
		System.out.println("Items were selected manually from shop / from web or mobiles application");
	}
	@Override
	public void payment(){
		System.out.println("Cash / UPI / CC / DC payments are allowed ");
	}
	@Override
	public void shipment(){
		System.out.println("items to be carried with customer  / home delivered");
	}
}


CityShop c1 = new CityShop();
c1. selectItems();
c1.payment();
c1.shipment();



class TownShop implements Shop{

	@Override // to check whether the same method from base class is overridden or not
	public void selectItems(){
		System.out.println("Items were selected manually from shop / from web or mobiles application");
	}
	@Override
	public void payment(){
		System.out.println("Cash / UPI / DC payments are allowed ");
	}
	@Override
	public void shipment(){
		System.out.println("items to be carried with customer  / home delivered");
	}
}


TownShop t = new TownShop();
t.selectItems();
t.payment():
t.shipment();

Interfaces defines a rule.

Till JDK7 an interface is strictly with abstract methods, ie we cannot write the method
def in the interfaces

JDK8 interfaces allow method definitons in the form default or static methods

Points to note in interface
-----------------------------
1. constructors cannot be defined in interfaces
2. Variables cannot be defined in the interfaces
3. final variables (constants) are allowed
4. If any variable is initialized in the interfaces, then it will become automatically a 
   final variable.
5.  Every method in interface is a public method even though we don't explicity define it as public

final int x = 10;
x++; // error

final is an access specifier can be applied on three levels:

1. variable -- The variable becomes constant, so its value cannot be changed.

2. method ---> This method cannot be overridden in the child classes

3. class --> This class cannot be used for inheritance


class Test{
	int x;
	int y;
	static int z;
	void test(){
	}
	static void test1(){
	}
}

Test t1 = new Test();
Test.z = 100 ; valid
Test.test1(); valid
t1.z= 10; valid
t1. test1(); valid

Test t2 = new Test();
Test.z = 300; valid
Test.test1(); valid
t2.z=200; valid
t2.test1(); valid



All Object will have diff memory spaces for Instance variables only
All objects have the same memory space for the methods



static 

either variable or method can be called directly on the class name / it can be called on the object
also


Static methods in the interface can be called only on  the interface, but not on the
implemented / child classes

We can have any number of default and static methods

Lambda Expressions
------------------

Lambda expressions are short form expression for representing the methods to have in 
functional program way

JDK8 --> OOP + Functional Programing 

Lamdba expressions are anonymous method without having method name, access modifier
or return  type.

public void display(){
	System.out.println("Hello");
}


() -> {
	System.out.println("Hello");
}

public void greet(String name){
	System.out.println("Hello "+name+" Welcome");
}


(String name) -> {
	System.out.println("Hello "+name+" Welcome");
}


1. In the lambda expression parameter datatypes are not  required


(name) -> {
	System.out.println("Hello "+name+" Welcome");
}

2. In the lambda expression if the body has only one statement, then {} isnot required

(name) -> System.out.println("Hello "+name+" Welcome");

3. In the lambda expression if there is only one parameter, then () also not required


name -> System.out.println("Hello "+name+" Welcome");

public int add(int a, int b){
	return a+b;
}

(a,b) -> return a+b;

4. In the lambda expressions, if there is only one statement, and if it is a return statement
then return keyword is also not required.

(a,b) -> a+b; 


public Boolean check(int n){

	if (n%2==0)
		return true;
	else
		return false;
}



n -> {

	if (n%2==0)
		return true;
	else
		return false;
}


n -> n%2 ==0 ;

public int fact(int n){
	int f=1;
	for(int i=2;i<=n;i++)
		f=f*i;
	return f;
}

n -> {
	int f=1;
	for(int i=2;i<=n;i++)
		f=f*i;
	return f;
};

Why do I need a lambda expression ? 
lambda  expressions are used to implement a functional interfaces

A functional interface is an interface which has only one abstract method.

@FunctionalInterface
interface Maths{
	public int add(int a, int b);
}


@FunctionalInterface
interface  Area{
	public double calArea(int radius);
	public  double volume(int length, int breadth,  int height);
}

JDK8 onwards


Inheritance -- 

1. Multiple Inheritance -- Interfaces


class


class A extends  ClassB, Class C ---> not allowed

class extends class, class ----> Invalid

class implements interface1, interface2 --> valid

class extends class implements interface ---> valid

class implements interface extends class ---> Invalid

interface implements interface ---> Invalid

interface extends interface ---> valid

interface extends interface1,interface1 -->valid




Modular Programming
-------------------

The divide the project into modules

Modular programming is an approach where a large program / project is divided into smaller
independent, reusable units called modules


Testing will be easier with modules



Java supports modular programming 
1. Methods
2. classes
3. packages
4. Java Modules (JDK9 ) onwards





Mathematics
1. add, sub, mul, div

public int add(){

}
public int sub(){

}



class Mathematics{



}

class ComplexNumbers{


}

class RealNumbers{



}





public 
private
protected
      (default)



Exception Handling
------------------
Exceptions are runtime errors

It is the process of handling the runtime errors


to read a file from the c drive and display its contents on monitor


s1
s2
s3 --> read file f1.txt from c drive --FileNotFoundException
s4
s5


When exceptions are araised, then our program execution will stop at that point



int c = a/b; (b!=0)  10/0 ---> Inderminant 
System.out.println(c); Runtime Error

Strig str = "Hai";

str.charAt(1) ---> a
str.chatAt(10) ---> RuntimeError ---> StringIndexOutOfBoundsException

int[] a = {1,2,3};

Sop(a[1]);----> 2
sop(a[10]);----> ArrayIndexOutOfBoundsException



try{
// opening a file
// write the code which may get runtime errors

}
catch(ExceptonObject){
	// code to execute when runtime error occurs


}
finally{
	// finally execute irrespective of errors
	// close file
}
next_statements;



1. If there is no error --> try --> finally --> next_statments

2. If error occurs and corresponding catch block available --> try -->catch--> finally --> next_statments

3. If error occurs and no corresponding catch block available --> try --> finally --> stops
execution


Object
 |
 |
Throwable ---> Error( Not handled)
 |
 |
Exception
 |-> IOException
 |-> InstantiationException
 |-> InitializationExeption
 |-> ClassNotFoundException
 |-> InterruptedException (checked Exception)
 |-> RuntimeException (Unchecked Exception)
	|->ArithmeticException
	|->IndexOutOfBoundsException
		|->ArrayIndexOutOfBounds
		|->StringIndexOutOfBounds
	|->NullPointerExcpetion

(Predefined or System defined exeptions)


class B extends A{

}


class ArithmeticException extends RuntimeException{


}




A child reference can be given to parent

Shop s = new CityShop();



A child exception should always be before the parent

A parent exception should always be after the child


Only one try block is not suggested while programing

multiple try catch blocks


Throws and Throw


throws is a keyword used to send / redirect the exception object without handling in the 
current block 


throw is a keyword which used to explicitly throw an exception object without having the
exeption condition raised 



throw keyword is used For creating the user defined exceptions





input age 

age <---read value from keyboard

if age >=18 then eligible to vote

age<18 not eligible to vote



-ve value or >100 both are invalid ages as per human beings



user defined exceptions

How to create user defined exceptions

1. write a class which will inherit from either exception / runtimexception


class InvalidAgeException extends RuntimeException{

public InvalidAgeException(){
	super("Age Cannot be negative or more than hundred");
}

}












